/*
    Copyright (C) 2016 Veronneau Techno. Conseil inc.
    For any questions you have regarding the solftware, feel free to get in touch by email.
    info@vertechcon.net

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection.Emit;
using System.Text;
using System.Threading.Tasks;

namespace Vertechcon.DynamicLibraries.Compilable.MethodConstructors
{
    /// <summary>
    /// Base class used to allow construction of custom expressions that returns a <see cref="TResult"/> result
    /// </summary>
    public abstract class ExpressionTreeFuncDelegateBuilder<TParam, TResult> : MethodConstructorBase, IMethodInjector
    {
        /// <summary>
        /// Method to implement in order to construct the expression intended to be injected in the dynamic type
        /// </summary>
        /// <returns></returns>
        protected abstract Expression<Func<TParam,TResult>> Create();

        /// <summary>
        /// Creates a delegate pointing to the compiled method created using the expression tree
        /// </summary>
        /// <returns></returns>
        public Func<TParam, TResult> Delegate()
        {
            return this.CreateDelegate<Func<TParam, TResult>>();
        }

        /// <summary>
        /// Generates a dynamically compiled method using the expression tree generated by the Create method
        /// </summary>
        /// <returns></returns>
        public Func<TParam, TResult> Build()
        {
            var ex = Create();
            return ex.Compile();
        }

        /// <summary>
        /// Injects the expression tree generated by the Create method into a method builder associated to a dynamic assembly
        /// </summary>
        /// <param name="methodBuilder"></param>
        public override void Inject(MethodBuilder methodBuilder)
        {
            var ex = Create();
            ex.CompileToMethod(methodBuilder);            
        }
    }

    /// <summary>
    /// Base class used to allow construction of custom expressions that returns a <see cref="TResult"/> result
    /// </summary>
    public abstract class ExpressionTreeFuncDelegateBuilder<TParam, TParam1, TResult> : MethodConstructorBase, IMethodInjector
    {
        /// <summary>
        /// Method to implement in order to construct the expression intended to be injected in the dynamic type
        /// </summary>
        /// <returns></returns>
        protected abstract Expression<Func<TParam, TParam1, TResult>> Create();

        /// <summary>
        /// Creates a delegate pointing to the compiled method created using the expression tree
        /// </summary>
        /// <returns></returns>
        public Func<TParam, TParam1, TResult> Delegate()
        {
            return this.CreateDelegate<Func<TParam, TParam1, TResult>>();
        }

        /// <summary>
        /// Generates a dynamically compiled method using the expression tree generated by the Create method
        /// </summary>
        /// <returns></returns>
        public Func<TParam, TParam1, TResult> Build()
        {
            var ex = Create();
            return ex.Compile();
        }

        /// <summary>
        /// Injects the expression tree generated by the Create method into a method builder associated to a dynamic assembly
        /// </summary>
        /// <param name="methodBuilder"></param>
        public override void Inject(MethodBuilder methodBuilder)
        {
            var ex = Create();
            ex.CompileToMethod(methodBuilder);
        }
    }

    /// <summary>
    /// Base class used to allow construction of custom expressions that returns a <see cref="TResult"/> result
    /// </summary>
    public abstract class ExpressionTreeFuncDelegateBuilder<TParam, TParam1, TParam2, TResult> : MethodConstructorBase, IMethodInjector
    {
        /// <summary>
        /// Method to implement in order to construct the expression intended to be injected in the dynamic type
        /// </summary>
        /// <returns></returns>
        protected abstract Expression<Func<TParam, TParam1, TParam2, TResult>> Create();

        /// <summary>
        /// Creates a delegate pointing to the compiled method created using the expression tree
        /// </summary>
        /// <returns></returns>
        public Func<TParam, TParam1, TParam2, TResult> Delegate()
        {
            return this.CreateDelegate<Func<TParam, TParam1, TParam2, TResult>>();
        }

        /// <summary>
        /// Generates a dynamically compiled method using the expression tree generated by the Create method
        /// </summary>
        /// <returns></returns>
        public Func<TParam, TParam1, TParam2, TResult> Build()
        {
            var ex = Create();
            return ex.Compile();
        }

        /// <summary>
        /// Injects the expression tree generated by the Create method into a method builder associated to a dynamic assembly
        /// </summary>
        /// <param name="methodBuilder"></param>
        public override void Inject(MethodBuilder methodBuilder)
        {
            var ex = Create();
            ex.CompileToMethod(methodBuilder);
        }
    }

    /// <summary>
    /// Base class used to allow construction of custom expressions that returns a <see cref="TResult"/> result
    /// </summary>
    public abstract class ExpressionTreeFuncDelegateBuilder<TParam, TParam1, TParam2, TParam3, TResult> : MethodConstructorBase, IMethodInjector
    {
        /// <summary>
        /// Method to implement in order to construct the expression intended to be injected in the dynamic type
        /// </summary>
        /// <returns></returns>
        protected abstract Expression<Func<TParam, TParam1, TParam2, TParam3, TResult>> Create();

        /// <summary>
        /// Creates a delegate pointing to the compiled method created using the expression tree
        /// </summary>
        /// <returns></returns>
        public Func<TParam, TParam1, TParam2, TParam3, TResult> Delegate()
        {
            return this.CreateDelegate<Func<TParam, TParam1, TParam2, TParam3, TResult>>();
        }

        /// <summary>
        /// Generates a dynamically compiled method using the expression tree generated by the Create method
        /// </summary>
        /// <returns></returns>
        public Func<TParam, TParam1, TParam2, TParam3, TResult> Build()
        {
            var ex = Create();
            return ex.Compile();
        }

        /// <summary>
        /// Injects the expression tree generated by the Create method into a method builder associated to a dynamic assembly
        /// </summary>
        /// <param name="methodBuilder"></param>
        public override void Inject(MethodBuilder methodBuilder)
        {
            var ex = Create();
            ex.CompileToMethod(methodBuilder);
        }
    }

    /// <summary>
    /// Base class used to allow construction of custom expressions that returns a <see cref="TResult"/> result
    /// </summary>
    public abstract class ExpressionTreeFuncDelegateBuilder<TParam, TParam1, TParam2, TParam3, TParam4, TResult> : MethodConstructorBase, IMethodInjector
    {
        /// <summary>
        /// Method to implement in order to construct the expression intended to be injected in the dynamic type
        /// </summary>
        /// <returns></returns>
        protected abstract Expression<Func<TParam, TParam1, TParam2, TParam3, TParam4, TResult>> Create();

        /// <summary>
        /// Creates a delegate pointing to the compiled method created using the expression tree
        /// </summary>
        /// <returns></returns>
        public Func<TParam, TParam1, TParam2, TParam3, TParam4, TResult> Delegate()
        {
            return this.CreateDelegate<Func<TParam, TParam1, TParam2, TParam3, TParam4, TResult>>();
        }

        /// <summary>
        /// Generates a dynamically compiled method using the expression tree generated by the Create method
        /// </summary>
        /// <returns></returns>
        public Func<TParam, TParam1, TParam2, TParam3, TParam4, TResult> Build()
        {
            var ex = Create();
            return ex.Compile();
        }

        /// <summary>
        /// Injects the expression tree generated by the Create method into a method builder associated to a dynamic assembly
        /// </summary>
        /// <param name="methodBuilder"></param>
        public override void Inject(MethodBuilder methodBuilder)
        {
            var ex = Create();
            ex.CompileToMethod(methodBuilder);
        }
    }
}
